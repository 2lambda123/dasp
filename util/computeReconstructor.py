#dasp, the Durham Adaptive optics Simulation Platform.
#Copyright (C) 2004-2016 Alastair Basden and Durham University.

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU Affero General Public License as
#published by the Free Software Foundation, either version 3 of the
#License, or (at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU Affero General Public License for more details.

#You should have received a copy of the GNU Affero General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""Uses cmod.svd to compute a reconstruction matrix from a poke matrix.
The poke matrix should be in csc sparse format, typically generated by
science.tomoRecon.

Suggested use:
dosvd() is the best way to do this currently... this will do the following:

First call computeRecon with mmapUt/Vt set to (possibly nonexistant) filenames, eg vt.mmap, ut.mmap, and with noGenInv==1.
Then call computeGenInv.

For large matricees, this is probably best carried out on a fast computer with lots of memory, eg the mac.

"""
import cmod.svd,util.FITS,time,cmod.utils,scipy.sparse,numpy
def computeRecon(filename,mmapUt=0,mmapVt=0,sparseGenInv=0,genInvMem=None,neig=0,minEig=0.01,fracEig=0.,minGIVal=1.,outFilename=None,noGenInv=0,nthreads=2,considerSwap=0):
    """Give the filename of the poke matrix to invert.
    mmapUt/mmapVt specifies whether Ut/Vt arrays should be memory mapped.
    If ncents is large, it is a good idea to set this for Vt.
    sparseGenInv specifies whether the generalised inverse should be sparse or not.
    A good idea for larger systems.
    neig, minEig and fracEig can be specified to determine how many eigenvalues/vectors are used.  neig sets the limit, minEig sets the minimum value to be accepted, and fracEig sets this value as a fraction of the maximum eigenvalue.
    minGIVal sets the minimum value to be put into the generalised inverse.
    if noGenInv==1 and sparseGenInv==0, no generalised inverse will be computed.
    considerswap is a flag to specify whether extra buffered memory is used when computing ut.  This is a good idea if ut cannot fit in memory at once.
    """
    f=util.FITS.Read(filename,savespace=1)
    nacts,ncents=eval(f[0]["parsed"]["SHAPE"])
    nacts=int(nacts)
    ncents=int(ncents)
    print "nacts %d, ncents %d"%(nacts,ncents)

    indptr=f[5]
    data=f[1]
    rowind=f[3]
    if indptr.dtype.char!="i":indptr=indptr.astype("i")
    if rowind.dtype.char!="i":rowind=rowind.astype("i")
    if data.dtype.char!="f":data=data.astype("f")
    print "indptr[-1]: %d, data shape: %d"%(indptr[-1],data.shape[0])
    useStoreFloat=1
    useSFloat=1
    prepareForGenInv=1
    smax=0
    if type(mmapUt)==type(""):
        utfname=mmapUt
    else:
        utfname=None
    if type(mmapVt)==type(""):
        vtfname=mmapVt
    else:
        vtfname=None
    if mmapUt:
        Ut=cmod.utils.mmapArray(utfname,(nacts,nacts),"f")
    else:
        Ut=numpy.zeros((nacts,nacts),"f")
    if mmapVt:
        Vt=cmod.utils.mmapArray(vtfname,(nacts,ncents),"f")
    else:
        Vt=numpy.zeros((nacts,ncents),"f")
    W=numpy.zeros((ncents,),"f")
    if sparseGenInv:
        if genInvMem==None:
            genInvMem=int(0.05*nacts*ncents)#5 percent sparsity
            print "Using %d elements for general inverse"%genInvMem
        #if genInvMem<=data.shape[0]:
        #    genInvData=data[:genInvMem]
        #    genInvRowind=rowind[:genInvMem]
        #else:
        genInvData=numpy.zeros((genInvMem,),"f")
        genInvRowind=numpy.zeros((genInvMem,),"i")
        #if ncents+1<=indptr.shape[0]:
        #    genInvIndptr=indptr[:ncents+1]
        #else:
        genInvIndptr=numpy.zeros((ncents+1,),"i")

                            
        genInv=cmod.svd.sparseMatrixCreate(genInvMem,nacts,ncents,genInvData,genInvRowind,genInvIndptr)
    elif noGenInv:
        genInv=None
    else:
        genInv=numpy.zeros((ncents,nacts),"f")
    t1=time.time()
    cmod.svd.dolibsvd(nacts,ncents,data[:indptr[-1]],rowind[:indptr[-1]],indptr,Ut,W,Vt,smax,neig,genInv,minEig,fracEig,useStoreFloat,useSFloat,minGIVal,prepareForGenInv,nthreads,considerSwap)
    t2=time.time()
    print "Remember to delete the mmap files, if created"
    print "Total Time taken: %g"%(t2-t1)
    if sparseGenInv:
        genInv=makeGenInv(genInvData,genInvRowind,genInvIndptr,nacts,ncents)
        if outFilename!=None:
            savecsc(genInv,outFilename,hdr=["NEIG    = %d"%neig,"MINEIG  = %g"%minEig,"FRACEIG = %g"%fracEig,"MINGIVAL= %g"%minGIVal])
            util.FITS.Write(W,outFilename,writeMode="a")
    return genInv,W,Ut,Vt

def computeGenInv(Ut,Vt,W,neig,neigForGenInv,fracEig,minEig,genInv,minGIVal,nthreads=2,maxElements=0,evalStart=0):
    """evalStart is the number of evals to ignore at the start - primarily for testing purposes."""
    if type(minGIVal)!=numpy.ndarray:
        minGIVal=numpy.array(minGIVal)
        if minGIVal.shape==():
            minGIVal.shape=(1,)
    minGIVal=minGIVal.astype(numpy.float64)
    cnt=numpy.zeros(minGIVal.shape,numpy.int64)
    t1=time.time()
    transposeGI=1#best at 1... most memory access efficient.
    cmod.svd.computeDenseGenInv(Ut,Vt,W,neig,neigForGenInv,fracEig,minEig,genInv,minGIVal,cnt,transposeGI,nthreads,evalStart)
    if transposeGI:
        nrows=genInv.shape[1]
        ncols=genInv.shape[0]
    else:
        nrows=genInv.shape[0]
        ncols=genInv.shape[1]
    #Now use maxElements and cnt to determine how many elements to create space for in the sparse array.
    if maxElements==0:
        maxElements=cnt[0]
    n=0
    for i in range(cnt.shape[0]):
        if cnt[i]<=maxElements:
            n=cnt[i]
            nindex=i
            break
    if n==0:
        n=cnt[-1]
        nindex=cnt.shape[0]-1
        print "WARNING: couldn't find the level at which to threshold for sparsification.  Attempting to use",n
    data=numpy.zeros((n,),numpy.float32)
    rowind=numpy.zeros((n,),numpy.int32)
    indptr=numpy.zeros((ncols+1,),numpy.int32)
    print "Sparsifying to %d points with min value %g (from %d, density %g)..."%(n,minGIVal[nindex],nrows*ncols,float(n)/(nrows*ncols))
    cmod.svd.sparsifyGenInv(genInv,minGIVal[nindex],transposeGI,nrows,data,rowind,indptr)
    csc=scipy.sparse.csc_matrix((numpy.array(data,copy=0),numpy.array(rowind,copy=0),numpy.array(indptr,copy=0)),(nrows,ncols))
    t2=time.time()
    print "Time for computeGenInv: %g"%(t2-t1)
    return csc,cnt

"""
#Use this to compute the reconstructor... (example)
import util.computeReconstructor
t1=time.time()
x,W,Ut,Vt=util.computeReconstructor.computeRecon("pmx_16.fits",mmapUt="ut.mmap",mmapVt="vt.mmap",noGenInv=1)
t2=time.time()
genInv=numpy.zeros((Vt.shape[1],Vt.shape[0]),"f")
neig=numpy.nonzero(W)[0][-1]+1
csc=util.computeReconstructor.computeGenInv(Ut,Vt,W,neig,0,0,0.1,genInv,0.3)
t3=time.time()
print "Times: %g %g"%(t2-t1,t3-t2)
"""
def getCpus():
    lines=open("/proc/cpuinfo").readlines()
    ncpu=0
    for line in lines:
        if ("processor" in line) and (":" in line):
            ncpu+=1
    if ncpu==0:
        print "Warning - couldn't determine number of CPUs, assuming 1"
        ncpu=1
    return ncpu
def test():
    x,W,Ut,Vt=computeRecon("pmx_16.fits",mmapUt="ut.mmap",mmapVt="vt.mmap",noGenInv=1)
    genInv=numpy.zeros((Vt.shape[1],Vt.shape[0]),"f")
    csc=computeGenInv(Ut,Vt,W,372,0,0,0.1,genInv,0.3)
    return csc

def dosvd(fname,outName="",fracEig=0,minEig=0.1,minRecon=[0.001,0.002,0.005,0.01,0.02,0.05,0.1,0.2,0.5,1.0],maxElements=None,evalStart=0):
    """
    This is currently the favoured way to do the generalised inverse computation.
    outName could be eg str(nsubx).  fname could be eg pmx_32.fits
    For a large case that takes days/hours to run, you'd probably be best doing this interactively, so that if necessary, you can rerun parts eg the computeGenInv with different parameters...
    """
    nthreads=1
    nthreads2=getCpus()
    print "Using %d threads for generalised inverse"%nthreads2
    t1=time.time()
    x,W,Ut,Vt=computeRecon(fname,mmapUt="ut%s.mmap"%outName,mmapVt="vt%s.mmap"%outName,noGenInv=1,nthreads=nthreads,considerSwap=1)
    t2=time.time()
    genInv=cmod.utils.mmapArray("genInv%s.mmap"%outName,(Vt.shape[1],Vt.shape[0]),"f")#numpy.zeros((Vt.shape[1],Vt.shape[0]),"f")
    neig=numpy.nonzero(W)[0][-1]+1
    util.FITS.Write(W[:neig+1],"W%s.fits"%outName,extraHeader=["UTSHAPE = %s"%str(Ut.shape),"VTSHAPE = %s"%str(Vt.shape)])
    if maxElements==None:
        maxElements=int(Vt.shape[0]*Vt.shape[1]*0.3)
        print "Using maxElements as %g"%maxElements
    elif maxElements<1:
        maxElements=int(Vt.shape[0]*Vt.shape[1]*maxElements)
        print "Using maxElements as %s"%maxElements

    csc,cnt=computeGenInv(Ut,Vt,W,neig,0,fracEig,minEig,genInv,minRecon,nthreads=nthreads2,maxElements=maxElements,evalStart=evalStart)
    t3=time.time()
    print "Times: %g %g"%(t2-t1,t3-t2)
    savecsc(csc,"rmx%s.fits"%outName)
    cmod.utils.mmapArrayFree(Ut)
    cmod.utils.mmapArrayFree(Vt)
    cmod.utils.mmapArrayFree(genInv)
    return csc

def recomputeGenInv(outName,minEig,outName2=None,minRecon=[0.001,0.002,0.005,0.01,0.02,0.05,0.1,0.2,0.3,0.5,1.],maxElements=None,evalStart=0):
    """Recomputes genInv for different values of minEig etc, using the Ut, Vt etc computed previously.
    outName should be whatever dosvd was called with.
    This assumes that the mmaped arrays, Ut and Vt haven't been changed.
    """
    nthread2=getCpus()
    if outName2==None:
        outName2=outName+"minEig%g"%minEig
    Wf=util.FITS.Read("W%s.fits"%outName)
    W=Wf[1].astype("f")
    Ut=cmod.utils.mmapArray("ut%s.mmap"%outName,eval(Wf[0]["parsed"]["UTSHAPE"]),"f")
    Vt=cmod.utils.mmapArray("vt%s.mmap"%outName,eval(Wf[0]["parsed"]["VTSHAPE"]),"f")
    neig=numpy.nonzero(W)[0][-1]+1
    genInv=cmod.utils.mmapArray("genInv%s.mmap"%outName,(Vt.shape[1],Vt.shape[0]),"f")
    if maxElements==None:
        maxElements=int(Vt.shape[0]*Vt.shape[1]*0.3)
    
    csc,cnt=computeGenInv(Ut,Vt,W,neig,0,0,minEig,genInv,minRecon,nthreads=nthread2,maxElements=maxElements,evalStart=evalStart)
    savecsc(csc,"rmx%s.fits"%outName2)
    cmod.utils.mmapArrayFree(Ut)
    cmod.utils.mmapArrayFree(Vt)
    cmod.utils.mmapArrayFree(genInv)
    return csc
def loadcsc(filename):
    f=util.FITS.Read(filename,savespace=1)
    csc=scipy.sparse.csc_matrix((numpy.array(f[1],copy=0),numpy.array(f[3],copy=0),numpy.array(f[5],copy=0)),eval(f[0]["parsed"]["SHAPE"]))
    return csc
def makeGenInv(genInvData,genInvRowind,genInvIndptr,nacts,ncents):
    csc=scipy.sparse.csc_matrix((numpy.array(genInvData,copy=0),numpy.array(genInvRowind,copy=0),numpy.array(genInvIndptr,copy=0)),(nacts,ncents))
    return csc

def savecsc(csc,filename,hdr=None):
    if type(hdr)==type(""):
        hdr=[hdr]
    elif type(hdr)==type(None):
        hdr=[]
    hdr.append("SHAPE   = %s"%str(csc.shape))
    util.FITS.Write(csc.data[:csc.indptr[-1]],filename,extraHeader=hdr)
    util.FITS.Write(csc.rowind[:csc.indptr[-1]],filename,writeMode="a")
    util.FITS.Write(csc.indptr,filename,writeMode="a")



if __name__=="__main__":
    import sys
    fname=sys.argv[1]
    outname=sys.argv[2]
    minEig=float(sys.argv[3])
    print "Doing svd with",fname,outname,minEig
    dosvd(fname,outname,minEig)
##     fname="pmx_32.fits"
##     minGIVal=1.
##     if fname=="pmx_8.fits":
##         minGIVal=1.74
##     elif fname=="pmx_16.fits":
##         minGIVal=0.
##     elif fname=="pmx_32.fits":
##         minGIVal=0.5
##     elif fname=="pmx_64.fits":
##         minGIVal=0.
##     genInv=computeRecon(fname,sparseGenInv=1,minEig=0.1,minGIVal=minGIVal)

def createSVDControl(pokemx,minEig):
    """create a SVD decomposition of pokemx (dense format).
    Only use this on small arrays...
    """
    import scipy.linalg
    t1=time.time()
    u,a,vt=scipy.linalg.svd(numpy.array(pokemx))
    svd_u=numpy.array(u)
    svd_a=numpy.array(a)
    svd_vt=numpy.array(vt)
    eigenVals=svd_a.copy()
    a=svd_a
    u=svd_u
    vt=svd_vt
    n_removed=0
    for i in range(len(a)):
        if a[i] < minEig:
            a[i]=0.
            n_removed += 1
    t2=time.time()
    print 'Removed %d modes from control matrix (took %g s), ignoring values below %g'%(n_removed,t2-t1,minEig)
    print 'Eigenvalues:',a
    #now do some sparsifying - for testing purposes... ie remove lowest values...
    ut=numpy.transpose(u)
    v=numpy.transpose(vt)
    #id=numpy.identity(len(a))
    #ai=numpy.multiply(a,id)
    #ai=numpy.where(ai != 0, 1/ai, 0)
    print "tomoRecon.createSVDControl - doing matrix multiplies"
    ai=numpy.where(a!=0,1/a,0)
    for i in range(ut.shape[0]):
        ut[i]*=ai[i]
    #the prev loop is the same as numpy.matrixmultiply(ai, ut) if ai is the version created by the next 3 (commented out) lines...
    #ai=numpy.identity(vt.shape[0],"d")
    #ai.flat[0:(vt.shape[0]+1)*a.shape[0]:vt.shape[0]+1]=numpy.where(a!=0,1/a,0)
    #ai=ai[:,:ut.shape[0]]
    #print "tomoRecon:",v.shape,ai.shape,ut.shape,vt.shape,a.shape,u.shape
    #print v.shape,ut.shape
    reconmx = numpy.matrixmultiply(v[:,:ut.shape[0]], ut)#numpy.matrixmultiply(ai, ut))
    t3=time.time()
    s1=reduce(lambda x,y:x*y,reconmx.shape)
    s2=s1-numpy.sum(reconmx.ravel()==0)
    print "tomoRecon.reconmx is %g full (%d/%d)"%(float(s2)/s1,s2,s1)
    return reconmx,eigenVals
